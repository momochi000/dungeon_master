#+title: Project

* Tasks
** DONE create structure for game state
CLOSED: [2024-01-08 Mon 13:36]
seems like defrecord is the way to do this
*** DONE create the file with the defrecord statement
CLOSED: [2023-12-29 Fri 15:08]

#+begin_example
dungeon-master.core=> (require '[dungeon-master.game-state :as game-state])
nil

dungeon-master.core=> (ns-aliases *ns*)
{game-state #object[clojure.lang.Namespace 0x2ee63961 "dungeon-master.game-state"]}
dungeon-master.core=> (ns-publics 'dungeon-master.game-state)
{->GameState #'dungeon-master.game-state/->GameState, map->GameState #'dungeon-master.game-state/map->GameState}
dungeon-master.core=> (def gs (game-state/->GameState "foo" "bar"))
#'dungeon-master.core/gs
#+end_example

*** DONE create some way to push some data fixture into neo4j
CLOSED: [2024-01-08 Mon 12:37]
some strawman graph, based on the dnd convo i had with gpt and the entities
extracted.
+ [X] function(ality) to create a person node in neo4j
+ [X] take the json emitted by gpt and parse it into clojure
+ [X] loop over the entities, and create nodes for each
  if they don't exist
+ [X] loop over relationships, and connect entities
  if they aren't already connected
** DONE create method to call gpt with some prompt on top of the user action
CLOSED: [2024-01-08 Mon 19:48]
** DONE create prompt to extract entities etc from gpt response
CLOSED: [2024-01-09 Tue 11:05]
** DONE update the graph according to entities and relationships in json
CLOSED: [2024-01-10 Wed 16:52]
from gpt's response to extract entities

MERGE alone is not sufficient to prevent re-insertion of entities.
I need to match on id and if there is no record, then re-insert
if there is a record, i need to do something smart about the description

I also shouldn't use ~id~ as a unique field, id is already a property of all nodes
I'll want to come up with something else and add a unique constraint like
~CREATE CONSTRAINT ON (p:Person) ASSERT p.my_field IS UNIQUE~
** DONE continue fleshing out fixture, use game chat from gpt
CLOSED: [2024-01-10 Wed 16:52]
** DONE update repl with common includes
CLOSED: [2024-01-12 Fri 13:52]
i shouldn't have to include everything over and over to test things in the repl
http://www.futurile.net/2020/03/07/clojure-lein-dev-experience-and-repl-tools/
https://dev.solita.fi/2014/03/18/pimp-my-repl.html
** DONE create initial character sheet data structure
CLOSED: [2024-01-19 Fri 18:32]
and insert it into the game state somewhere
** DONE character sheet becomes part of the context
CLOSED: [2024-01-27 Sat 17:34]
at least some simple descriptive part of it
** TODO add tests
** TODO create/expose primary interface
the game loop where I can type somethign in and execute ~run-turn~ every turn
** TODO fix environment variable setting

i shouldn't have to pass in environment variables to set the database url, it
should be set as bolt://graphdb:<port> as given by the docker-compose config.
but for the nix repl environment i need it to be "bolt://localhost"

These should be things i can set in the project.clj and profiles.clj files but
they aren't working.
** TODO Replace usage of TransactionWork
TransactionWork is deprecated in favor of TransactionCallback
** TODO move game_state.clj under game/
** TODO set up a beginning game state
** TODO playtest
** TODO figure out how to query the database on each turn
to provide and generate the context needed for the current turn when calling the
LLM
user input -> extract entities -> cypher query?
or user input -> vector search?
or both..?
** TODO turn the results from neo4j query into some nested map structure
this is step 1 in an experiment. i don't know if this is the best representation
of the graph to place in memory but the intent is to get closer to finding out.

alternatively i'd turn it into clojure's loom or ubergraph

perhaps the best way to represent the graph is simply a graphviz dot text format?

I believe GPT is smart enough to read that and understand the structure without
having to do anything fancy with turning a deeply nested map into a prompt
somehow

I don't actually have to do anything here. I can just take the output of neo4j
as a string or a table -> string and feed that directly into the prompt. GPT is
smart enough to know how to understand it.
** TODO Create some way to handle database setup
e.g. create constraints and indices
* Notes
** neo4j
*** databases
neo4j begins with 2 databases:
+ system
  the system database described above, containing meta-data on the DBMS and security configuration.

+ neo4j
  the default database, named using the config option dbms.default_database=neo4j.
*** workings
**** an updating query always either fully succeeds or does not succeed at all.
**** transactions
+--------------------------------------------------+-------------------------------------------------------------------+
| Explicit                                         | Implicit                                                           |
+--------------------------------------------------+-------------------------------------------------------------------+
| Opened by the user.                              | Opened automatically.                                              |
+--------------------------------------------------+--------------------------------------------------------------------+
| Can execute multiple Cypher queries in sequence. | Can execute a single Cypher query.                                 |
+--------------------------------------------------+-------------------------------------------------------------------+
| Committed, or rolled back, by the user.          | Committed automatically when a transactions finishes successfully. |
+--------------------------------------------------+-------------------------------------------------------------------+
*** documentation
**** bolt driver wiki
https://github.com/neo4j/neo4j-java-driver/wiki
